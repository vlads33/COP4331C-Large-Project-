{"_id":"culvert","_rev":"8-d9619784092bb79ee772bb5476864149","name":"culvert","description":"Channel for easy streaming of work between complex logics.","dist-tags":{"latest":"0.1.2"},"versions":{"0.1.0":{"name":"culvert","version":"0.1.0","description":"Channel for easy streaming of work between complex logics.","main":"channel.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":{"type":"git","url":"git://github.com/creationix/culvert.git"},"keywords":["channel","stream","csp","js-git"],"author":{"name":"Tim Caswell","email":"tim@creationix.com"},"license":"MIT","bugs":{"url":"https://github.com/creationix/culvert/issues"},"homepage":"https://github.com/creationix/culvert","_id":"culvert@0.1.0","dist":{"shasum":"b782677dc1c82b7572598180eebf291a68c4be5e","tarball":"https://registry.npmjs.org/culvert/-/culvert-0.1.0.tgz","integrity":"sha512-Mc5ux/JBpmER2BrZL31NzWOZjddo9Pz0QCsjHgMj7PgLVNzBTPWiKcank9vDNWoVxxBiu2sdgVzb1/XTzYatmQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAPccvxK8IgOn8aOlLNTtYmCBJApQxnZlRezVTq6w1ILAiAak0NvYQG2N5gjkbAEWS2QxJqq3KXnTz0zhu0oBh3VVA=="}]},"_from":".","_npmVersion":"1.4.3","_npmUser":{"name":"creationix","email":"tim@creationix.com"},"maintainers":[{"name":"creationix","email":"tim@creationix.com"}]},"0.1.1":{"name":"culvert","version":"0.1.1","description":"Channel for easy streaming of work between complex logics.","main":"channel.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":{"type":"git","url":"git://github.com/creationix/culvert.git"},"keywords":["channel","stream","csp","js-git"],"author":{"name":"Tim Caswell","email":"tim@creationix.com"},"license":"MIT","bugs":{"url":"https://github.com/creationix/culvert/issues"},"homepage":"https://github.com/creationix/culvert","_id":"culvert@0.1.1","dist":{"shasum":"857094c1ae8e1e6e23b4d6da2878289d2e66e50c","tarball":"https://registry.npmjs.org/culvert/-/culvert-0.1.1.tgz","integrity":"sha512-0RPCTj7tXi8OQfcOJVWLHh76s4p6DJGFBjMHeGzaTEp3Ljq8lyldecFlG5hMGzFzKU99BLznA+68O5ahyoFADw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCnsUHaQWcDZglg72dCIiUsySfP68dweu8GQ5JWWd0z+wIgBt5tWxNMwTJ9GO1+lK0QMwre0otv85Y8myjby0KoTVU="}]},"_from":".","_npmVersion":"1.4.3","_npmUser":{"name":"creationix","email":"tim@creationix.com"},"maintainers":[{"name":"creationix","email":"tim@creationix.com"}]},"0.1.2":{"name":"culvert","version":"0.1.2","description":"Channel for easy streaming of work between complex logics.","main":"channel.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":{"type":"git","url":"git://github.com/creationix/culvert.git"},"keywords":["channel","stream","csp","js-git"],"author":{"name":"Tim Caswell","email":"tim@creationix.com"},"license":"MIT","bugs":{"url":"https://github.com/creationix/culvert/issues"},"homepage":"https://github.com/creationix/culvert","_id":"culvert@0.1.2","_shasum":"9502f5f0154a2d5a22a023e79f71cc936fa6ef6f","_from":".","_npmVersion":"1.4.9","_npmUser":{"name":"creationix","email":"tim@creationix.com"},"maintainers":[{"name":"creationix","email":"tim@creationix.com"}],"dist":{"shasum":"9502f5f0154a2d5a22a023e79f71cc936fa6ef6f","tarball":"https://registry.npmjs.org/culvert/-/culvert-0.1.2.tgz","integrity":"sha512-yi1x3EAWKjQTreYWeSd98431AV+IEE0qoDyOoaHJ7KJ21gv6HtBXHVLX74opVSGqcR8/AbjJBHAHpcOy2bj5Gg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC0XK3cxsCs/CXxts6EgC7SgfZqtH1JnymDlOg8aOGY0AIhANvdZlnU70G9m/MkuekExBSZmnF6e27ZKV0HB1sjvued"}]}}},"readme":"Culvert\n=======\n\nChannel for easy streaming of work between complex logics.\n\nThis is used in place of streams for CSP style flow.  I use it in js-git for network and file streams.\n\nUsually, you'll want to split sides to create a duplex channel.\n\n```js\nvar makeChannel = require('culvert');\n\nvar serverChannel = makeChannel();\nvar clientChannel = makeChannel();\n\nfunction connect(host, port) {\n\n  // This represents the server-side of the duplex pipe\n  var socket = {\n    put: serverChannel.put,\n    drain: serverChannel.drain,\n    take: cientChannel.drain\n  };\n\n  // When we want to send data to the consumer...\n  socket.put(someData);\n\n  // When we want to read from the consumer...\n  socket.take(function (err, item) {});\n\n  // Return the client's end of the pipe\n  return {\n    put: clientChannel.put,\n    drain: clientChannel.drain,\n    take: serverChannel.take\n  };\n}\n```\n\nIf you want/need to preserve back-pressure and honor the buffer limit,\nmake sure to wait for drain when `put` returns false.\n\n```js\n// Start a read\nsocket.take(onData);\n\nfunction onData(err, item) {\n  if (err) throw err;\n  if (item === undefined) {\n    // End stream when nothing comes out\n    console.log(\"done\");\n  }\n  else if (socket.put(item)) {\n    // If put returned true, keep reading\n    socket.take(onData);\n  }\n  else {\n    // Otherwise pause and wait for drain\n    socket.drain(onDrain);\n  }\n}\n\nfunction onDrain(err) {\n  if (err) throw err;\n  // Resume reading\n  socket.take(onData);\n}\n```\n\nIf you're using continuables and generators, it's much nicer syntax.\n\n```js\nvar item;\nwhile (item = yield socket.take, item !== undefined) {\n  if (!socket.put(item)) yield socket.drain;\n}\nconsole.log(\"done\");\n```\n\nAlso the continuable version won't blow the stack if lots of events come in on the same tick.\n\n## makeChannel(bufferSize, monitor)\n\nCreate a new channel.\n\nThe optional bufferSize is how many items can be in the queue and still be considered not full.\n\nThe optional monitor function will get called with `(type, item)` where `type` is either \"put\" or \"take\" and `item` is the value being put or taken.\n\n## channel.put(item) -> more\n\nThis is a sync function.  You can add as many items to the channel as you want and it will queue them up.\n\nThis returns `true` when the queue is smaller than bufferSize, it returns false if you should wait for drain.\n\n## channel.drain(callback)\n\nDrain is a reusable continuable.  Use this when you want to wait for the buffer to be below the bufferSize mark.\n\n## channel.take(callback)\n\nTake is for reading.  The callback will have the next item.  It may call sync or it may be later.\n","maintainers":[{"name":"creationix","email":"tim@creationix.com"}],"time":{"modified":"2022-06-14T05:50:40.708Z","created":"2014-07-19T04:28:38.716Z","0.1.0":"2014-07-19T04:28:38.716Z","0.1.1":"2014-07-19T05:44:15.035Z","0.1.2":"2014-07-25T21:25:28.688Z"},"homepage":"https://github.com/creationix/culvert","keywords":["channel","stream","csp","js-git"],"repository":{"type":"git","url":"git://github.com/creationix/culvert.git"},"author":{"name":"Tim Caswell","email":"tim@creationix.com"},"bugs":{"url":"https://github.com/creationix/culvert/issues"},"license":"MIT","readmeFilename":"README.md"}